render() {
        // 1. Atomic Clear: Remove the entire previous frame (Header + Ribbons + Footer)
        if (this.lastFrameHeight > 0) {
            process.stdout.write(`\x1B[${this.lastFrameHeight}A\x1B[0J`);
        }

        // 2. Build current frame: Static Header -> Active Ribbons (Fixed Height) -> Footer
        const frame = [];
        const header = new HeaderWidget(this.config, this.sourceHash, this.dataName, this.dataSize, this.mode, this.width);
        frame.push(header.render());

        const windowSize = (this.config.WINDOW && this.config.WINDOW.SIZE) || 4;
        let renderedCount = 0;

        // Render active (not yet acked) generations
        for (const id of this.allIds) {
            const gen = this.generations.get(id);
            if (!gen.acked) {
                const ribbon = new RibbonWidget(gen, this.mode);
                frame.push(padBox(ribbon.render(), this.width));
                renderedCount++;
                if (renderedCount >= windowSize) break;
            }
        }

        // Fill remaining slots with IDLE placeholders to maintain FIXED body height
        while (renderedCount < windowSize) {
            const slotId = renderedCount + 1;
            frame.push(padBox(`\x1B[90m[Slot ${String(slotId).padStart(2, '0')}] <....................>  IDLE\x1B[0m`, this.width));
            renderedCount++;
        }

        const footer = new FooterWidget(
            { ...this.stats, startTime: this.startTime, total: this.config.TOTAL_GENS },
            this.receivedHash,
            this.receivedHash === this.sourceHash,
            this.mode,
            this.width
        );
        frame.push(footer.render());

        // 3. Atomic Print
        const output = frame.join('\n');
        process.stdout.write(output + '\n');
        this.lastFrameHeight = output.split('\n').length;
    }