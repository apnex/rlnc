--- threading/worker_pool.js
+++ threading/worker_pool.js
@@ -5,13 +5,13 @@
 
 class WorkerPool extends EventEmitter {
-    constructor(numThreads = 4) {
+    constructor(numThreads = 4, scriptName = 'encoder_worker.js') {
         super();
         this.workers = [];
         this.nextWorkerIdx = 0;
 
-        console.log(`[WorkerPool] Spawning ${numThreads} v7 threads (Zero-Copy Enabled)...`);
+        console.log(`[WorkerPool] Spawning ${numThreads} ${scriptName} threads...`);
 
         for (let i = 0; i < numThreads; i++) {
-            const w = new Worker(path.join(__dirname, 'encoder_worker.js'));
+            const w = new Worker(path.join(__dirname, scriptName));
             w.on('message', (msg) => {
                 if (msg.type === 'PACKET') {
@@ -25,4 +25,7 @@
                     this.emit('packet', safeView);
+                } else if (msg.type === 'SOLVED') {
+                    this.emit('solved', msg.genId, Buffer.from(msg.data));
                 } else if (msg.type === 'STATS') {
@@ -32,4 +35,13 @@
 
-            w.on('error', (err) => console.error(`Worker ${i} error:`, err));
+            w.on('error', (err) => console.error(`Worker ${i} [${scriptName}] error:`, err));
             this.workers.push(w);
         }
     }
+
+    // v8 Optimization: Sharded Dispatch for stateful workers (Decoders)
+    dispatch(genId, msg, transferList = []) {
+        const idx = genId % this.workers.length;
+        this.workers[idx].postMessage(msg, transferList);
+    }
+

--- threading/generation_encoder.js
+++ threading/generation_encoder.js
@@ -21,5 +21,5 @@
 
 	this.sentCounts = new Map();
-        this.pool = new WorkerPool(this.config.SYSTEM.THREADS);
+        this.pool = new WorkerPool(this.config.SYSTEM.THREADS, 'encoder_worker.js');
 
         this.pool.on('packet', (buffer) => {

--- threading/generation_decoder.js
+++ threading/generation_decoder.js
@@ -1,13 +1,24 @@
-const BlockDecoder = require('../core/block_decoder');
 const EventEmitter = require('events');
+const WorkerPool = require('./worker_pool');
 
 class GenerationDecoder extends EventEmitter {
     constructor(config) {
         super();
         this.config = config;
-        this.decoders = new Map(); // GenID -> BlockDecoder
         this.completed = new Map(); // GenID -> Buffer
+
+        // v8 Velocity: Multi-Threaded Decoding
+        // We use the same hardware-aware thread count as the encoder
+        this.pool = new WorkerPool(this.config.SYSTEM.THREADS || 4, 'decoder_worker.js');
+
+        this.pool.on('solved', (genId, data) => {
+            if (!this.completed.has(genId)) {
+                this.completed.set(genId, data);
+                this.emit('generation_ready', genId);
+            }
+        });
     }
 
     static create(config) {
@@ -16,16 +27,10 @@
 
     addPiece(piece) {
-        if (this.completed.has(piece.genId)) return; // Already solved
-
-        if (!this.decoders.has(piece.genId)) {
-            this.decoders.set(piece.genId, new BlockDecoder(this.config));
-        }
-
-        const decoder = this.decoders.get(piece.genId);
-        const done = decoder.addPiece(piece);
-
-        if (done) {
-            this.completed.set(piece.genId, decoder.getData());
-            this.decoders.delete(piece.genId); // Free memory
-            this.emit('generation_ready', piece.genId);
-        }
+        if (this.completed.has(piece.genId)) return;
+        
+        // Sharded Dispatch: The Pool handles routing GenID to the correct worker
+        this.pool.dispatch(piece.genId, {
+            type: 'ADD_PIECE',
+            piece,
+            config: this.config
+        });
     }
